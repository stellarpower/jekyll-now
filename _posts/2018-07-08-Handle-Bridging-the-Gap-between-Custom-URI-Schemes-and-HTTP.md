---
layout: post
title: Handle - Bridging the Gap between Custom URI Schemes and HTTP
tags: 'Ionic, Android, Web'
published: true
---

I've spent the last few weeks working sporadically on an app with [Monzo](https://www.monzo.com). 
<img style="float: right;" width="320" height="120" src="https://cdn.greenhouse.io/external_greenhouse_job_boards/logos/000/005/589/resized/Monzo_horz_lightbg.png?1491325535"> If you've not heard of them, they're one of the various FinTech banks starting up in the UK, boasting a rich set of features and some pretty decent technological innovations. Well, they're not that impressive, but we all know the banking world moves at the speed of a Bracchiosaur. It seems they're giving lots of freebies to students to promote their platform; I'm always a little bit suspicious when computer science students are that excited about something involving the real world. One of their most promising features, however, is a public API. From the start the aim is to be open and allow customers to access their own data. This is a welcome change, and I decided to write a small app to help me with some regular tasks. 

I'm more of a systems programmer than app developer, and a while back I was investigating which technology to invest into learning, I went with [Ionic](https://ionicframework.com/) upon a recommendation. Ionic's based on Angular and so the app is based on old HTML, not my favourite 'language' by any means but I figured it's be quicker than learning my way around the Android API. I was wrong. To put it bluntly the process has been a small nightmare, and I rather regret investing in either of the two technologies.

Firstly, Ionic is somewhat of a tower of bricks. ![Ionic (Artist's impression)](http://www.baractivity.com/user/products/large/brgm-011.jpg)It's not quite held together with electrical tape. Far from it, it seems to have been put together well. However there are so many individual things going on in there it quickly becomes spaghetti junction. The famework's reasonably well-designed but the apps you end up writing quickly end up being the opposite. Despite being one solution for desktop and mobile, everything requires a cordova plugin, without a corresponding web plugin, and you're pretty much back to writing something purely for Android in no time at all.

The issue on the Monzo side (I still prefer it when they were called Mondo) is that the API requires one to implement a full OAuth2 login flow. This is meant to be easy, and surely it is if firstly, you know what you're doing, and secondly, you're targeting a native platform and not using one thing after another with Ionic. Frankly this is overkill given that the developers expressly prohibit anyone using any apps developed with the API from accessing another person's data, with the exception of a handful of close relations. Luckily you can give it a quick go with a temporary token, a great idea, but when you actually want to do something, you need the full flow. I know that OAuth is the future but it's a headache that you really don't need, especially when I have the Monzo app on my phone that never logs me out, and when their API currently can't move any money into or out of the account. One of the many issues I can remember coming across was the fact that the API servers would only accept data in a url-encoded form (the whole thing is powered by REST) and not in the json format that's become quite popular. I would get seemingly random errors as the server struggled to parse my form fields. and it took me a while to get round this and manually encode my parameters as a string.

The thing with OAuth is that it's not really a standard. It's been adapted so freely that a developer can't rely on a simple library to serve for any website. Google a while ago disabled OAuth requests in the InAppBrowser on Android so all of my Ionic plugins are useless for me to play with my Google data. The fix shouldn't be too hard but I've not got round to finalising it yet. In the case of Monzo, instead of asking for a username and password, they use a one-factor two-factor authentication if you will, and instead just send you an email with the link in that. I like this system. It means you don't have to worry about remembering a specific password and can just get on with opening an app in a few seconds. All well and good, but this then breaks the application flow as you can no longer be redirected by the InAppBrowser and so the OAuth flow never completes in the plugin I used. By exiting my application to open GMail, I'm then stuck with a callback that's useless.

![Email from Monzo](/_posts/MonzoEmail.png)



The modern way around this is to have a URL specified by you to open your app by registering a handler with the system. As far as I can tell, there are two systems. You can use a regular HTTP URL, which is ueful if you do own a domain for your app, or you can use a custom 'handler' of the form myapp://. The Ionic plugin was for the latter so I went with that. Well, that took a while to get working, and my main callback had to be embedded into the main page's HTML as a script tag rather than in the TypeScript logic of the page (bugfix pending). Then as the function is outside the scope of Angular, it's not easy to get my component to update itself and start parsing the returned URL, so I just gave up and added a second button to my application to process the login. This is the problem with Ionic. To get things to work, you have to do something hacky. 
  
## Now we come to the point of this post. 

A URL of the form myapp://callback will be picked up by myapp. Android, created by Google, recognises this and opens the app when I put this URL into **Firefox**. But as soon as I do so in Chrome, also made by Google, it just tries to search for the phrase. and on top of that, Gmail, again made by Google, actually strips the link out of the email. There's a button there and I can't click on it, even in the desktop site. If you inspect the element, the href has actually been taken out of the anchor tag.

So I'm stuck with an app that needs to be opened with a URI that can't be. A bit of searching reveals there's no quick fix to this, however I have devised a simple solution and got the necessary permissions for it to work server-side thanks to my friends on Discord a couple of years further into their degress than me. If you happen to live in Scotland please do check out [CompSoc](https://comp-soc.com/), whilst first and foremost a University of Edinburgh society, we are very keen on making links with people outwith the university, be they professionals or hobbyists or anything inbetween. <img style="float: right" width="260" height="300" src="https://wiki.tardis.ed.ac.uk/tardis.png?cbedf"></img>In fact, even if you don't live up North, check it out. We'd love to have you give us a talk as that means we get free pizza. Luckily I have a modest amount of very flexible rackspace thanks to the wonderful people at [TARDIS](https://www.tardis.ed.ac.uk), who work closely with but are separate from CompSoc (well we're all members of both really), and a quick rewrite rule enables me, or anyone who finds this, to turn a https URL into a custom URI scheme link.


If you go to https://tardis.ed.ac.uk/~blaze/Handle because I couldn't think of anything catchier than Handle, you'll find a redirect rule that takes the first item in the URI and uses that as the protocol, and everything afterwards is forwarded as it is.

So, https://tardis.ed.ac.uk/~blaze/Handle/ftp/foo.co.uk/bar?baz=watermelons will be redirected to ftp://foo.co.uk/bar?baz=watermelons

Using this system, we quickly get a nice, friendly https link that GMail can't strip for us, and still open our app successfully. I just had to change my OAuth client settings to reflect the new URL instead. This URL is free for anyone to use, I hope it will be useful to someone. If you're worried about the risks of sending your OAuth secrets to a third-party server, if you're obtaining a code through the callback system and later exchanging the code for a token through a normal POST, then you should be fine as as far as I know the code is useless without the client secret as that is necessary to obtain a functioning token. In any case we're all students or were recently and are far too busy to notice what's coming through our servers. I don't even know where the Apache logs are kept, never mind having read access to them.

If however you do want things on your own server, the following in your .htaccess will do the trick under Apache:

`RedirectMatch ~user/Handle/([^/]+)/(.*) $1://$2`

Well, that's it for not, I hope this in some way useful to someone.
